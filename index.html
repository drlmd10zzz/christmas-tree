<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Merry Christmas</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      display: grid;
      place-items: center;
      background: radial-gradient(circle at top, #0b1a3a, #040814 70%);
      overflow: hidden;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
    }
    .wrap { position: relative; width: min(720px, 92vw); }
    canvas { width: 100%; height: auto; display: block; border-radius: 20px; box-shadow: 0 20px 80px rgba(0,0,0,.5); }
    .msg {
      position: absolute; left: 0; right: 0; bottom: 16px;
      text-align: center; padding: 10px 14px;
      background: rgba(0,0,0,.25); backdrop-filter: blur(6px);
      margin: 0 16px; border-radius: 14px;
      font-size: 16px; line-height: 1.4;
    }
    .hint {
      position: absolute; top: 14px; left: 14px;
      font-size: 12px; opacity: .75;
      background: rgba(0,0,0,.22); padding: 8px 10px; border-radius: 12px;
    }
    button {
      position: absolute; top: 14px; right: 14px;
      border: 0; border-radius: 12px; padding: 8px 10px;
      background: rgba(255,255,255,.12); color: #fff; cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,.18); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="scene" width="900" height="1200"></canvas>
    <div class="hint">提示：点击星星</div>
    <button id="toggle">暂停/继续</button>
    <div class="msg" id="message"></div>
  </div>

  <script>
    const GIRL_NAME = "绮思";
    const SINCE = "2025-12-21";
    const LINE1 = `Merry Christmas, ${GIRL_NAME}。`;
    const LINE2 = `From now on, 我想一直在你身边。`;

    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;

    let running = true;
    document.getElementById("toggle").onclick = () => running = !running;

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const rng = mulberry32(20251224);

    const snow = Array.from({length: 180}, () => ({
      x: rng() * W, y: rng() * H, r: 1 + rng()*2.4, v: 0.6 + rng()*1.6, dx: (rng()-0.5)*0.6
    }));

    const lights = [];
    const hearts = [];

    const star = { x: W*0.5, y: H*0.14, r: 26 };

    const msgEl = document.getElementById("message");
    const fullText = `${LINE1}<br>${LINE2}<br><span style="opacity:.85;font-size:13px;">Since ${SINCE}</span>`;
    let idx = 0;
    function typewriter() {
      const plain = fullText.replace(/<br>/g, "\n").replace(/<[^>]*>/g, "");
      if (idx < plain.length) {
        msgEl.textContent = plain.slice(0, idx + 1);
        idx++;
        setTimeout(typewriter, 35);
      } else {
        msgEl.innerHTML = fullText;
      }
    }
    typewriter();

    function spawnHearts(x, y) {
      for (let i = 0; i < 44; i++) {
        const a = rng()*Math.PI*2;
        const sp = 2 + rng()*4;
        hearts.push({
          x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp,
          life: 65 + Math.floor(rng()*35),
          s: 8 + rng()*6
        });
      }
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (canvas.height / rect.height);
      const dx = mx - star.x, dy = my - star.y;
      if (Math.hypot(dx, dy) < star.r * 1.4) spawnHearts(star.x, star.y);
    });

    function drawBackground() {
      ctx.save();
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < 120; i++) {
        const x = (i*37 % W) + rng()*2;
        const y = (i*83 % (H*0.6)) + rng()*2;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillRect(x, y, 1.2, 1.2);
      }
      ctx.restore();
    }

    function drawSnow() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      for (const p of snow) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
        if (running) {
          p.y += p.v;
          p.x += p.dx;
          if (p.y > H) { p.y = -10; p.x = rng()*W; }
          if (p.x < -20) p.x = W+20;
          if (p.x > W+20) p.x = -20;
        }
      }
      ctx.restore();
    }

    function drawTreeBody() {
      const cx = W * 0.5;
      const top = H * 0.18;
      const bottom = H * 0.78;
      const height = bottom - top;

      const layers = 7;
      const layerH = height * 0.17;
      const overlap = layerH * 0.42;
      const baseW = 45;
      const growW = 42;

      ctx.save();
      for (let i = 0; i < layers; i++) {
        const yTop = top + i * (layerH - overlap);
        const yBottom = yTop + layerH;
        const layerW = baseW + i * growW;

        ctx.beginPath();
        ctx.moveTo(cx, yTop);
        ctx.lineTo(cx - layerW, yBottom);
        ctx.lineTo(cx + layerW, yBottom);
        ctx.closePath();

        ctx.fillStyle = `rgba(20, 120, 70, ${0.92 - i * 0.06})`;
        ctx.fill();
      }

      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.beginPath();
      ctx.ellipse(cx, bottom + 115, 320, 85, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function buildLights() {
      lights.length = 0;

      const cx = W * 0.5;
      const top = H * 0.18;
      const bottom = H * 0.78;
      const height = bottom - top;

      const layers = 6;
      const layerH = height * 0.14;
      const overlap = layerH * 0.35;
      const baseW = 70;
      const growW = 55;

      function halfWidthAtY(y) {
        const step = (layerH - overlap);
        const idx = Math.max(0, Math.min(layers - 1, Math.floor((y - top) / step)));
        const yTop = top + idx * step;
        const yBottom = yTop + layerH;
        if (y < yTop || y > yBottom) return 0;
        const layerW = baseW + idx * growW;
        const t = (y - yTop) / (yBottom - yTop);
        return layerW * t;
      }

      let tries = 0;
      while (lights.length < 150 && tries < 800) {
        tries++;
        const y = top + rng() * (bottom - top);
        const w = halfWidthAtY(y);
        if (w <= 2) continue;
        const x = cx + (rng() - 0.5) * (w * 1.8);
        lights.push({
          x, y,
          s: 2.6 + rng() * 4.2,
          phase: rng() * Math.PI * 2,
          hue: Math.floor(rng() * 360)
        });
      }
    }
    buildLights();

    function drawStar(t) {
      const {x, y} = star;
      const pulse = 0.85 + 0.15*Math.sin(t*0.08);
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(pulse, pulse);
      ctx.beginPath();
      const spikes = 5, outer = 26, inner = 12;
      for (let i = 0; i < spikes*2; i++) {
        const r = (i % 2 === 0) ? outer : inner;
        const a = i * Math.PI / spikes - Math.PI/2;
        ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 215, 80, 0.95)";
      ctx.shadowColor = "rgba(255, 215, 80, 0.8)";
      ctx.shadowBlur = 18;
      ctx.fill();
      ctx.restore();
    }

    function drawLights(t) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const L of lights) {
        const on = Math.sin(t * 0.12 + L.phase) > 0;
        const alpha = on ? 0.95 : 0.25;
        ctx.beginPath();
        ctx.arc(L.x, L.y, L.s, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${L.hue}, 90%, 60%, ${alpha})`;
        ctx.shadowColor = `hsla(${L.hue}, 90%, 60%, ${alpha})`;
        ctx.shadowBlur = on ? 14 : 3;
        ctx.fill();
      }
      ctx.globalCompositeOperation = "source-over";
      ctx.restore();
    }

    function drawHearts() {
      ctx.save();

      function heartPath(x, y, size) {
        const topCurveHeight = size * 0.3;
        ctx.beginPath();
        ctx.moveTo(x, y + topCurveHeight);
        ctx.bezierCurveTo(
          x - size, y - size * 0.2,
          x - size * 1.25, y + size * 0.85,
          x, y + size * 1.25
        );
        ctx.bezierCurveTo(
          x + size * 1.25, y + size * 0.85,
          x + size, y - size * 0.2,
          x, y + topCurveHeight
        );
        ctx.closePath();
      }

      for (let i = hearts.length - 1; i >= 0; i--) {
        const p = hearts[i];
        const a = Math.max(0, p.life / 90);

        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(255,105,180,0.9)";
        ctx.shadowColor = "rgba(255,105,180,0.55)";
        ctx.shadowBlur = 10;

        heartPath(p.x, p.y, p.s);
        ctx.fill();

        if (running) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.05;
          p.life -= 1;
        }
        if (p.life <= 0) hearts.splice(i, 1);
      }

      ctx.restore();
    }

    function drawTag() {
      const cx = W * 0.5;
      const bottom = H * 0.78;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.fillRect(W*0.32, bottom + 150, W*0.36, 54);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "24px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(`To ${GIRL_NAME}`, cx, bottom + 185);
      ctx.restore();
    }

    let t = 0;
    function loop() {
      ctx.clearRect(0, 0, W, H);
      drawBackground();
      drawSnow();
      drawTreeBody();
      drawLights(t);
      drawStar(t);
      drawHearts();
      drawTag();
      if (running) t++;
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
